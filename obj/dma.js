// Generated by CoffeeScript 1.4.0

/*1964js - JavaScript/HTML5 port of 1964 - N64 emulator
Copyright (C) 2012 Joel Middendorf

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/


(function() {
  "use strict";

  var C1964jsDMA, root;

  C1964jsDMA = (function() {

    function C1964jsDMA(memory, interrupts, pif) {
      this.startTime = 0;
      this.memory = memory;
      this.interrupts = interrupts;
      this.pif = pif;
      this.audio = void 0;
    }

    C1964jsDMA.prototype.copyCartToDram = function(pc, isDelaySlot) {
      var end, from, remaining, to, transfer;
      end = this.memory.getInt32(this.memory.piUint8Array, consts.PI_WR_LEN_REG);
      to = this.memory.getInt32(this.memory.piUint8Array, consts.PI_DRAM_ADDR_REG);
      from = this.memory.getInt32(this.memory.piUint8Array, consts.PI_CART_ADDR_REG);
      log("pi dma write " + (end + 1) + " bytes from " + dec2hex(from) + " to " + dec2hex(to));
      end &= 0x00ffffff;
      to &= 0x00ffffff;
      transfer = end;
      remaining = -1;
      if ((from & 0x10000000) !== 0) {
        from &= 0x0fffffff;
        if (from + end + 1 > this.memory.rom.byteLength) {
          transfer = this.memory.rom.byteLength - from - 1;
          remaining = end - transfer;
        }
        while (transfer >= 0) {
          this.memory.rdramUint8Array[to] = this.memory.romUint8Array[from];
          to++;
          from++;
          --transfer;
        }
      } else {
        alert("pi reading from somewhere other than cartridge domain");
        while (end-- >= 0) {
          this.memory.rdramUint8Array[to] = this.memory.lb(from);
          from++;
          to++;
        }
      }
      this.interrupts.clrFlag(this.memory.piUint8Array, consts.PI_STATUS_REG, consts.PI_STATUS_IO_BUSY | consts.PI_STATUS_DMA_BUSY);
      this.interrupts.triggerPIInterrupt(pc, isDelaySlot);
    };

    C1964jsDMA.prototype.copySiToDram = function(pc, isDelaySlot) {
      var end, from, to;
      end = 63;
      to = this.memory.getInt32(this.memory.siUint8Array, consts.SI_DRAM_ADDR_REG);
      from = this.memory.getInt32(this.memory.siUint8Array, consts.SI_PIF_ADDR_RD64B_REG);
      if (from !== 0x1FC007C0) {
        throw Error("Unhandled: SI_DRAM_ADDR_RD64B_REG = " + from);
      }
      log("si dma write " + (end + 1) + " bytes from " + dec2hex(from) + " to " + dec2hex(to));
      end &= 0x00ffffff;
      to &= 0x0fffffff;
      from &= 0x0000ffff;
      this.pif.processPif();
      while (end >= 0) {
        this.memory.rdramUint8Array[to] = this.memory.pifUint8Array[from];
        to++;
        from++;
        --end;
      }
      this.interrupts.setFlag(this.memory.siUint8Array, consts.SI_STATUS_REG, consts.SI_STATUS_INTERRUPT);
      this.interrupts.triggerSIInterrupt(pc, isDelaySlot);
    };

    C1964jsDMA.prototype.copyDramToAi = function(pc, isDelaySlot) {
      var from, length;
      length = this.memory.getInt32(this.memory.aiUint8Array, consts.AI_LEN_REG);
      from = this.memory.getInt32(this.memory.aiUint8Array, consts.AI_DRAM_ADDR_REG);
      length &= 0x00ffffff;
      from &= 0x0fffffff;
      if (this.audio === undefined) {
        this.audio = new C1964jsAudio();
      }
      if (this.audio.processAudio(this.memory, from, length) === false) {
        this.interrupts.clrFlag(this.memory.aiUint8Array, consts.AI_STATUS_REG, consts.AI_STATUS_FIFO_FULL);
      }
      this.interrupts.setFlag(this.memory.aiUint8Array, consts.AI_STATUS_REG, consts.AI_STATUS_FIFO_FULL);
    };

    C1964jsDMA.prototype.copyDramToSi = function(pc, isDelaySlot) {
      var end, from, to;
      end = 63;
      to = this.memory.getInt32(this.memory.siUint8Array, consts.SI_PIF_ADDR_WR64B_REG);
      from = this.memory.getInt32(this.memory.siUint8Array, consts.SI_DRAM_ADDR_REG);
      if (to !== 0x1FC007C0) {
        throw Error("Unhandled: SI_DRAM_ADDR_RD64B_REG = " + from);
      }
      log("si dma read " + (end + 1) + " bytes from " + dec2hex(from) + " to " + dec2hex(to));
      end &= 0x00ffffff;
      to &= 0x0000ffff;
      from &= 0x0fffffff;
      while (end >= 0) {
        this.memory.pifUint8Array[to] = this.memory.rdramUint8Array[from];
        to++;
        from++;
        --end;
      }
      this.interrupts.setFlag(this.memory.siUint8Array, consts.SI_STATUS_REG, consts.SI_STATUS_INTERRUPT);
      this.interrupts.triggerSIInterrupt(pc, isDelaySlot);
    };

    C1964jsDMA.prototype.copySpToDram = function(pc, isDelaySlot) {
      alert("todo: copySpToDram");
    };

    C1964jsDMA.prototype.copyDramToSp = function(pc, isDelaySlot) {
      var end, from, to;
      end = this.memory.getInt32(this.memory.spReg1Uint8Array, consts.SP_RD_LEN_REG);
      to = this.memory.getInt32(this.memory.spReg1Uint8Array, consts.SP_MEM_ADDR_REG);
      from = this.memory.getInt32(this.memory.spReg1Uint8Array, consts.SP_DRAM_ADDR_REG);
      log("sp dma read " + (end + 1) + " bytes from " + dec2hex(from) + " to " + dec2hex(to));
      end &= 0x00000FFF;
      to &= 0x00001fff;
      from &= 0x00ffffff;
      while (end >= 0) {
        this.memory.spMemUint8Array[to] = this.memory.rdramUint8Array[from];
        to++;
        from++;
        --end;
      }
      this.memory.setInt32(this.memory.spReg1Uint8Array, consts.SP_DMA_BUSY_REG, 0);
      if (this.memory.getInt32(this.memory.spReg1Uint8Array, consts.SP_STATUS_REG) & (consts.SP_STATUS_DMA_BUSY | consts.SP_STATUS_IO_FULL | consts.SP_STATUS_DMA_FULL)) {
        alert("hmm..todo: an sp fp status flag is blocking from continuing");
      }
      this.interrupts.clrFlag(this.memory.spReg1Uint8Array, consts.SP_STATUS_REG, consts.SP_STATUS_DMA_BUSY);
      this.interrupts.setFlag(this.memory.spReg1Uint8Array, consts.SP_STATUS_REG, consts.SP_STATUS_HALT);
    };

    return C1964jsDMA;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.C1964jsDMA = C1964jsDMA;

  root.log = function(message) {
    "use strict";

  };

}).call(this);

// Generated by CoffeeScript 1.4.0

/*1964js - JavaScript/HTML5 port of 1964 - N64 emulator
Copyright (C) 2012 Joel Middendorf

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/


(function() {
  /** @const */ SP_STATUS_HALT = 0x0001;

  /** @const */ SP_STATUS_BROKE = 0x0002;

  /** @const */ SP_STATUS_DMA_BUSY = 0x0004;

  /** @const */ SP_STATUS_DMA_FULL = 0x0008;

  /** @const */ SP_STATUS_IO_FULL = 0x0010;

  /** @const */ SP_STATUS_SSTEP = 0x0020;

  /** @const */ SP_STATUS_INTR_BREAK = 0x0040;

  /** @const */ SP_STATUS_YIELD = 0x0080;

  /** @const */ SP_STATUS_YIELDED = 0x0100;

  /** @const */ SP_STATUS_TASKDONE = 0x0200;

  /** @const */ SP_STATUS_SIG3 = 0x0400;

  /** @const */ SP_STATUS_SIG4 = 0x0800;

  /** @const */ SP_STATUS_SIG5 = 0x1000;

  /** @const */ SP_STATUS_SIG6 = 0x2000;

  /** @const */ SP_STATUS_SIG7 = 0x4000;

  /** @const */ SP_CLR_HALT = 0x0000001;

  /** @const */ SP_SET_HALT = 0x0000002;

  /** @const */ SP_CLR_BROKE = 0x0000004;

  /** @const */ SP_CLR_INTR = 0x0000008;

  /** @const */ SP_SET_INTR = 0x0000010;

  /** @const */ SP_CLR_SSTEP = 0x0000020;

  /** @const */ SP_SET_SSTEP = 0x0000040;

  /** @const */ SP_CLR_INTR_BREAK = 0x0000080;

  /** @const */ SP_SET_INTR_BREAK = 0x0000100;

  /** @const */ SP_CLR_YIELD = 0x0000200;

  /** @const */ SP_SET_YIELD = 0x0000400;

  /** @const */ SP_CLR_YIELDED = 0x0000800;

  /** @const */ SP_SET_YIELDED = 0x0001000;

  /** @const */ SP_CLR_TASKDONE = 0x0002000;

  /** @const */ SP_SET_TASKDONE = 0x0004000;

  /** @const */ SP_CLR_SIG3 = 0x0008000;

  /** @const */ SP_SET_SIG3 = 0x0010000;

  /** @const */ SP_CLR_SIG4 = 0x0020000;

  /** @const */ SP_SET_SIG4 = 0x0040000;

  /** @const */ SP_CLR_SIG5 = 0x0080000;

  /** @const */ SP_SET_SIG5 = 0x0100000;

  /** @const */ SP_CLR_SIG6 = 0x0200000;

  /** @const */ SP_SET_SIG6 = 0x0400000;

  /** @const */ SP_CLR_SIG7 = 0x0800000;

  /** @const */ SP_SET_SIG7 = 0x1000000;

  var C1964jsInterrupts, currentHack, root;

  currentHack = 0;

  C1964jsInterrupts = function(core, cp0) {
    "use strict";
    this.setException = function(exception, causeFlag, pc, isFromDelaySlot) {
      cp0[consts.CAUSE] |= exception;
      cp0[consts.CAUSE] |= causeFlag;
    };
    this.processException = function(pc, isFromDelaySlot) {
      if ((cp0[consts.STATUS] & consts.IE) === 0) {
        return false;
      }
      if ((cp0[consts.STATUS] & consts.EXL) !== 0) {
        return false;
      }
      cp0[consts.CAUSE] &= 0xFFFFFF83;
      cp0[consts.STATUS] |= consts.EXL;
      if (isFromDelaySlot === true) {
        cp0[consts.CAUSE] |= consts.BD;
        cp0[consts.EPC] = pc - 4;
      } else {
        cp0[consts.CAUSE] &= ~consts.BD;
        cp0[consts.EPC] = pc;
      }
      if (core.doOnce === 0) {
        core.flushDynaCache();
      }
      core.doOnce = 1;
      core.p = 0x80000180;
      return true;
    };
    this.triggerCompareInterrupt = function(pc, isFromDelaySlot) {
      this.setException(consts.EXC_INT, consts.CAUSE_IP8, pc, isFromDelaySlot);
    };
    this.triggerPIInterrupt = function(pc, isFromDelaySlot) {
      var value;
      this.setFlag(core.memory.miUint8Array, consts.MI_INTR_REG, consts.MI_INTR_PI);
      value = core.memory.miUint8Array[consts.MI_INTR_MASK_REG] << 24 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 1] << 16 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 2] << 8 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 3];
      if ((value & consts.MI_INTR_MASK_PI) !== 0) {
        this.setException(consts.EXC_INT, consts.CAUSE_IP3, pc, isFromDelaySlot);
      }
    };
    this.triggerSPInterrupt = function(pc, isFromDelaySlot) {
      var value;
      this.setFlag(core.memory.miUint8Array, consts.MI_INTR_REG, consts.MI_INTR_SP);
      value = core.memory.miUint8Array[consts.MI_INTR_MASK_REG] << 24 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 1] << 16 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 2] << 8 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 3];
      if ((value & consts.MI_INTR_MASK_SP) !== 0) {
        this.setException(consts.EXC_INT, consts.CAUSE_IP3, pc, isFromDelaySlot);
      }
    };
    this.triggerVIInterrupt = function(pc, isFromDelaySlot) {
      var value;
      this.setFlag(core.memory.miUint8Array, consts.MI_INTR_REG, consts.MI_INTR_VI);
      value = core.memory.miUint8Array[consts.MI_INTR_MASK_REG] << 24 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 1] << 16 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 2] << 8 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 3];
      if ((value & consts.MI_INTR_MASK_VI) !== 0) {
        this.setException(consts.EXC_INT, consts.CAUSE_IP3, pc, isFromDelaySlot);
      }
    };
    this.triggerSIInterrupt = function(pc, isFromDelaySlot) {
      var value;
      this.setFlag(core.memory.miUint8Array, consts.MI_INTR_REG, consts.MI_INTR_SI);
      value = core.memory.miUint8Array[consts.MI_INTR_MASK_REG] << 24 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 1] << 16 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 2] << 8 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 3];
      if ((value & consts.MI_INTR_MASK_SI) !== 0) {
        this.setException(consts.EXC_INT, consts.CAUSE_IP3, pc, isFromDelaySlot);
      }
    };
    this.triggerAIInterrupt = function(pc, isFromDelaySlot) {
      var value;
      this.setFlag(core.memory.miUint8Array, consts.MI_INTR_REG, consts.MI_INTR_AI);
      value = core.memory.miUint8Array[consts.MI_INTR_MASK_REG] << 24 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 1] << 16 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 2] << 8 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 3];
      if ((value & consts.MI_INTR_MASK_AI) !== 0) {
        this.setException(consts.EXC_INT, consts.CAUSE_IP3, pc, isFromDelaySlot);
      }
    };
    this.triggerDPInterrupt = function(pc, isFromDelaySlot) {
      var value;
      this.setFlag(core.memory.miUint8Array, consts.MI_INTR_REG, consts.MI_INTR_DP);
      value = core.memory.miUint8Array[consts.MI_INTR_MASK_REG] << 24 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 1] << 16 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 2] << 8 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 3];
      if ((value & consts.MI_INTR_MASK_DP) !== 0) {
        this.setException(consts.EXC_INT, consts.CAUSE_IP3, pc, isFromDelaySlot);
      }
    };
    this.triggerRspBreak = function() {
      var value;
      this.setFlag(core.memory.spReg1Uint8Array, consts.SP_STATUS_REG, consts.SP_STATUS_TASKDONE | consts.SP_STATUS_BROKE | consts.SP_STATUS_HALT);
      value = core.memory.spReg1Uint8Array[consts.SP_STATUS_REG] << 24 | core.memory.spReg1Uint8Array[consts.SP_STATUS_REG + 1] << 16 | core.memory.spReg1Uint8Array[consts.SP_STATUS_REG + 2] << 8 | core.memory.spReg1Uint8Array[consts.SP_STATUS_REG + 3];
      if ((value & consts.SP_STATUS_INTR_BREAK) !== 0) {
        this.triggerSPInterrupt(0, false);
      }
    };
    this.clearMIInterrupt = function(flag) {
      var value;
      this.clrFlag(core.memory.miUint8Array, consts.MI_INTR_REG, flag);
      value = core.memory.miUint8Array[consts.MI_INTR_MASK_REG] << 24 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 1] << 16 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 2] << 8 | core.memory.miUint8Array[consts.MI_INTR_MASK_REG + 3];
      if ((value & (core.memory.getUint32(core.memory.miUint8Array, consts.MI_INTR_REG))) !== 0) {
        cp0[consts.CAUSE] &= ~consts.CAUSE_IP3;
      }
    };
    this.readVI = function(offset) {
      switch (offset) {
        case consts.VI_CURRENT_REG:
          if ((currentHack += 1) === 625) {
            currentHack = 0;
          }
          return (((core.memory.viUint8Array[offset] << 24 | core.memory.viUint8Array[offset + 1] << 16 | core.memory.viUint8Array[offset + 2] << 8 | core.memory.viUint8Array[offset + 3]) & 0xfffffffe) + currentHack) | 0;
        default:
          return core.memory.viUint8Array[offset] << 24 | core.memory.viUint8Array[offset + 1] << 16 | core.memory.viUint8Array[offset + 2] << 8 | core.memory.viUint8Array[offset + 3];
      }
    };
    this.writeVI = function(offset, value, pc, isFromDelaySlot) {
      switch (offset) {
        case consts.VI_ORIGIN_REG:
          core.memory.setInt32(core.memory.viUint8Array, offset, value);
          break;
        case consts.VI_CURRENT_REG:
          this.clearMIInterrupt(consts.MI_INTR_VI);
          core.memory.setInt32(core.memory.viUint8Array, offset, value);
          break;
        case consts.VI_INTR_REG:
          core.memory.setInt32(core.memory.viUint8Array, offset, value);
          break;
        default:
          core.memory.setInt32(core.memory.viUint8Array, offset, value);
      }
    };
    this.writePI = function(offset, value, pc, isFromDelaySlot) {
      switch (offset) {
        case consts.PI_WR_LEN_REG:
          core.memory.setInt32(core.memory.piUint8Array, offset, value);
          core.dma.copyCartToDram(pc, isFromDelaySlot);
          break;
        case consts.PI_RD_LEN_REG:
          core.memory.setInt32(core.memory.piUint8Array, offset, value);
          alert("write to PI_RD_LEN_REG");
          core.dma.copyDramToCart(pc, isFromDelaySlot);
          break;
        case consts.PI_DRAM_ADDR_REG:
          core.memory.setInt32(core.memory.piUint8Array, offset, value);
          break;
        case consts.PI_CART_ADDR_REG:
          core.memory.setInt32(core.memory.piUint8Array, offset, value);
          break;
        case consts.PI_STATUS_REG:
          this.writePIStatusReg(value, pc, isFromDelaySlot);
          break;
        default:
          core.memory.setInt32(core.memory.piUint8Array, offset, value);
      }
    };
    this.writeSI = function(offset, value, pc, isFromDelaySlot) {
      switch (offset) {
        case consts.SI_DRAM_ADDR_REG:
          core.memory.setInt32(core.memory.siUint8Array, offset, value);
          break;
        case consts.SI_STATUS_REG:
          this.writeSIStatusReg(value, pc, isFromDelaySlot);
          break;
        case consts.SI_PIF_ADDR_RD64B_REG:
          core.memory.setInt32(core.memory.siUint8Array, offset, value);
          core.dma.copySiToDram(pc, isFromDelaySlot);
          break;
        case consts.SI_PIF_ADDR_WR64B_REG:
          core.memory.setInt32(core.memory.siUint8Array, offset, value);
          core.dma.copyDramToSi(pc, isFromDelaySlot);
          break;
        default:
          core.memory.setInt32(core.memory.siUint8Array, offset, value);
      }
    };
    this.readSI = function(offset) {
      switch (offset) {
        case consts.SI_STATUS_REG:
          this.readSIStatusReg();
          return core.memory.getInt32(core.memory.siUint8Array, offset);
        default:
          return core.memory.getInt32(core.memory.siUint8Array, offset);
      }
    };
    this.readSIStatusReg = function() {
      if ((core.memory.getUint32(core.memory.miUint8Array, consts.MI_INTR_REG) & consts.MI_INTR_SI) !== 0) {
        this.setFlag(core.memory.siUint8Array, consts.SI_STATUS_REG, consts.SI_STATUS_INTERRUPT);
      } else {
        this.clrFlag(core.memory.siUint8Array, consts.SI_STATUS_REG, consts.SI_STATUS_INTERRUPT);
      }
    };
    this.readAI = function(offset) {
      switch (offset) {
        case consts.AI_LEN_REG:
          core.kfi -= 1;
          if (core.kfi === 0) {
            core.kfi = 512;
            this.clrFlag(core.memory.aiUint8Array, consts.AI_STATUS_REG, consts.AI_STATUS_FIFO_FULL);
            return 0;
          }
          return 0;
        case consts.AI_STATUS_REG:
          return core.memory.getInt32(core.memory.aiUint8Array, offset);
        default:
          return core.memory.getInt32(core.memory.aiUint8Array, offset);
      }
    };
    this.writeAI = function(offset, value, pc, isFromDelaySlot) {
      switch (offset) {
        case consts.AI_DRAM_ADDR_REG:
          core.memory.setInt32(core.memory.aiUint8Array, offset, value);
          break;
        case consts.AI_LEN_REG:
          core.memory.setInt32(core.memory.aiUint8Array, offset, value);
          core.dma.copyDramToAi(pc, isFromDelaySlot);
          break;
        case consts.AI_STATUS_REG:
          this.clearMIInterrupt(consts.MI_INTR_AI);
          break;
        case consts.AI_DACRATE_REG:
          core.memory.setInt32(core.memory.aiUint8Array, offset, value);
          break;
        case consts.AI_CONTROL_REG:
          core.memory.setInt32(core.memory.aiUint8Array, offset, value & 1);
          break;
        default:
          core.memory.setInt32(core.memory.aiUint8Array, offset, value);
      }
    };
    this.writeMI = function(offset, value, pc, isFromDelaySlot) {
      switch (offset) {
        case consts.MI_INIT_MODE_REG:
          this.writeMIModeReg(value);
          break;
        case consts.MI_INTR_MASK_REG:
          this.writeMIIntrMaskReg(value, pc, isFromDelaySlot);
          break;
        case consts.MI_VERSION_REG:
        case consts.MI_INTR_REG:
          break;
        default:
          core.memory.setInt32(core.memory.miUint8Array, offset, value);
      }
    };
    this.readSPReg1 = function(offset) {
      var temp;
      switch (offset) {
        case consts.SP_STATUS_REG:
          return core.memory.getInt32(core.memory.spReg1Uint8Array, offset);
        case consts.SP_SEMAPHORE_REG:
          temp = core.memory.getInt32(core.memory.aiUint8Array, offset);
          core.memory.setInt32(core.memory.spReg1Uint8Array, offset, 1);
          return temp;
        default:
          return core.memory.getInt32(core.memory.spReg1Uint8Array, offset);
      }
    };
    this.writeSPReg1 = function(offset, value, pc, isFromDelaySlot) {
      switch (offset) {
        case consts.SP_STATUS_REG:
          this.writeSPStatusReg(value, pc, isFromDelaySlot);
          break;
        case consts.SP_SEMAPHORE_REG:
          core.memory.setInt32(core.memory.spReg1Uint8Array, offset, 0);
          break;
        case consts.SP_WR_LEN_REG:
          core.memory.setInt32(core.memory.spReg1Uint8Array, offset, value);
          core.dma.copySpToDram(pc, isFromDelaySlot);
          break;
        case consts.SP_RD_LEN_REG:
          core.memory.setInt32(core.memory.spReg1Uint8Array, offset, value);
          core.dma.copyDramToSp(pc, isFromDelaySlot);
          break;
        default:
          core.memory.setInt32(core.memory.spReg1Uint8Array, offset, value);
      }
    };
    this.writeSPReg2 = function(offset, value, pc, isFromDelaySlot) {
      switch (offset) {
        case consts.SP_PC_REG:
          core.memory.setInt32(core.memory.spReg2Uint8Array, offset, value & 0x00000FFC);
          break;
        default:
          core.memory.setInt32(core.memory.spReg2Uint8Array, offset, value);
      }
    };
    this.setFlag = function(where, offset, flag) {
      var value;
      value = core.memory.getUint32(where, offset);
      value |= flag;
      core.memory.setInt32(where, offset, value);
    };
    this.clrFlag = function(where, offset, flag) {
      var value;
      value = core.memory.getUint32(where, offset);
      value &= ~flag;
      core.memory.setInt32(where, offset, value);
    };
    this.writeMIModeReg = function(value) {
      if (value & consts.MI_SET_RDRAM) {
        this.setFlag(core.memory.miUint8Array, consts.MI_INIT_MODE_REG, consts.MI_MODE_RDRAM);
      } else {
        if (value & consts.MI_CLR_RDRAM) {
          this.clrFlag(core.memory.miUint8Array, consts.MI_INIT_MODE_REG, consts.MI_MODE_RDRAM);
        }
      }
      if (value & consts.MI_SET_INIT) {
        this.setFlag(core.memory.miUint8Array, consts.MI_INIT_MODE_REG, consts.MI_MODE_INIT);
      } else {
        if (value & consts.MI_CLR_INIT) {
          this.clrFlag(core.memory.miUint8Array, consts.MI_INIT_MODE_REG, consts.MI_MODE_INIT);
        }
      }
      if (value & consts.MI_SET_EBUS) {
        this.setFlag(core.memory.miUint8Array, consts.MI_INIT_MODE_REG, consts.MI_MODE_EBUS);
      } else {
        if (value & consts.MI_CLR_EBUS) {
          this.clrFlag(core.memory.miUint8Array, consts.MI_INIT_MODE_REG, consts.MI_MODE_EBUS);
        }
      }
      if (value & consts.MI_CLR_DP_INTR) {
        this.clearMIInterrupt(consts.MI_INTR_DP);
      }
    };
    this.writeMIIntrMaskReg = function(value, pc, isFromDelaySlot) {
      if (value & consts.MI_INTR_MASK_SP_SET) {
        this.setFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_SP);
      } else {
        if (value & consts.MI_INTR_MASK_SP_CLR) {
          this.clrFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_SP);
        }
      }
      if (value & consts.MI_INTR_MASK_SI_SET) {
        this.setFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_SI);
      } else {
        if (value & consts.MI_INTR_MASK_SI_CLR) {
          this.clrFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_SI);
        }
      }
      if (value & consts.MI_INTR_MASK_AI_SET) {
        this.setFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_AI);
      } else {
        if (value & consts.MI_INTR_MASK_AI_CLR) {
          this.clrFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_AI);
        }
      }
      if (value & consts.MI_INTR_MASK_VI_SET) {
        this.setFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_VI);
      } else {
        if (value & consts.MI_INTR_MASK_VI_CLR) {
          this.clrFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_VI);
        }
      }
      if (value & consts.MI_INTR_MASK_PI_SET) {
        this.setFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_PI);
      } else {
        if (value & consts.MI_INTR_MASK_PI_CLR) {
          this.clrFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_PI);
        }
      }
      if (value & consts.MI_INTR_MASK_DP_SET) {
        this.setFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_DP);
      } else {
        if (value & consts.MI_INTR_MASK_DP_CLR) {
          this.clrFlag(core.memory.miUint8Array, consts.MI_INTR_MASK_REG, consts.MI_INTR_DP);
        }
      }
      if ((core.memory.getUint32(core.memory.miUint8Array, consts.MI_INTR_MASK_REG) & 0x0000003F & core.memory.getUint32(core.memory.miUint8Array, consts.MI_INTR_REG)) !== 0) {
        this.setException(consts.EXC_INT, consts.CAUSE_IP3, pc, isFromDelaySlot);
      }
    };
    this.writeSIStatusReg = function(value, pc, isFromDelaySlot) {
      this.clrFlag(core.memory.siUint8Array, consts.SI_STATUS_REG, consts.SI_STATUS_INTERRUPT);
    };
    this.writeSPStatusReg = function(value, pc, isFromDelaySlot) {
      var spDmemTask, tempSr;
      tempSr = core.memory.getUint32(core.memory.spReg1Uint8Array, consts.SP_STATUS_REG);
      if (value & SP_CLR_BROKE) {
        tempSr &= ~consts.SP_STATUS_BROKE;
      }
      if (value & SP_SET_INTR) {
        this.triggerSPInterrupt(pc, isFromDelaySlot);
      } else {
        if (value & SP_CLR_INTR) {
          this.clearMIInterrupt(consts.MI_INTR_SP);
        }
      }
      if (value & SP_SET_SSTEP) {
        tempSr |= SP_STATUS_SSTEP;
      } else {
        if (value & SP_CLR_SSTEP) {
          tempSr &= ~SP_STATUS_SSTEP;
        }
      }
      if (value & SP_SET_INTR_BREAK) {
        tempSr |= SP_STATUS_INTR_BREAK;
      } else {
        if (value & SP_CLR_INTR_BREAK) {
          tempSr &= ~SP_STATUS_INTR_BREAK;
        }
      }
      if (value & SP_SET_YIELD) {
        tempSr |= SP_STATUS_YIELD;
      } else {
        if (value & SP_CLR_YIELD) {
          tempSr &= ~SP_STATUS_YIELD;
        }
      }
      if (value & SP_SET_YIELDED) {
        tempSr |= SP_STATUS_YIELDED;
      } else {
        if (value & SP_CLR_YIELDED) {
          tempSr &= ~SP_STATUS_YIELDED;
        }
      }
      if (value & SP_SET_TASKDONE) {
        tempSr |= SP_STATUS_TASKDONE;
      } else {
        if (value & SP_CLR_YIELDED) {
          tempSr &= ~SP_STATUS_YIELDED;
        }
      }
      if (value & SP_SET_SIG3) {
        tempSr |= SP_STATUS_SIG3;
      } else {
        if (value & SP_CLR_SIG3) {
          tempSr &= ~SP_STATUS_SIG3;
        }
      }
      if (value & SP_SET_SIG4) {
        tempSr |= SP_STATUS_SIG4;
      } else {
        if (value & SP_CLR_SIG4) {
          tempSr &= ~SP_STATUS_SIG4;
        }
      }
      if (value & SP_SET_SIG5) {
        tempSr |= SP_STATUS_SIG5;
      } else {
        if (value & SP_CLR_SIG5) {
          tempSr &= ~SP_STATUS_SIG5;
        }
      }
      if (value & SP_SET_SIG6) {
        tempSr |= SP_STATUS_SIG6;
      } else {
        if (value & SP_CLR_SIG6) {
          tempSr &= ~SP_STATUS_SIG6;
        }
      }
      if (value & SP_SET_SIG7) {
        tempSr |= SP_STATUS_SIG7;
      } else {
        if (value & SP_CLR_SIG7) {
          tempSr &= ~SP_STATUS_SIG7;
        }
      }
      if (value & SP_SET_HALT) {
        tempSr |= SP_STATUS_HALT;
        core.memory.setInt32(core.memory.spReg1Uint8Array, consts.SP_STATUS_REG, tempSr);
      } else if (value & SP_CLR_HALT) {
        if ((tempSr & SP_STATUS_BROKE) === 0) {
          tempSr &= ~SP_STATUS_HALT;
          core.memory.setInt32(core.memory.spReg1Uint8Array, consts.SP_STATUS_REG, tempSr);
          spDmemTask = core.memory.getUint32(core.memory.spMemUint8Array, consts.SP_DMEM_TASK);
          this.runSPTask(spDmemTask);
        } else {
          core.memory.setInt32(core.memory.spReg1Uint8Array, consts.SP_STATUS_REG, tempSr);
        }
      }
    };
    this.writeDPCStatusReg = function(value, pc, isFromDelaySlot) {
      if (value & consts.DPC_CLR_XBUS_DMEM_DMA) {
        this.clrFlag(core.memory.dpcUint8Array, consts.DPC_STATUS_REG, consts.DPC_STATUS_XBUS_DMEM_DMA);
      }
      if (value & consts.DPC_SET_XBUS_DMEM_DMA) {
        this.setFlag(core.memory.dpcUint8Array, consts.DPC_STATUS_REG, consts.DPC_STATUS_XBUS_DMEM_DMA);
      }
      if (value & consts.DPC_CLR_FREEZE) {
        this.clrFlag(core.memory.dpcUint8Array, consts.DPC_STATUS_REG, consts.DPC_STATUS_FREEZE);
      }
      if (value & consts.DPC_SET_FREEZE) {
        this.setFlag(core.memory.dpcUint8Array, consts.DPC_STATUS_REG, consts.DPC_STATUS_FREEZE);
      }
      if (value & consts.DPC_CLR_FLUSH) {
        this.clrFlag(core.memory.dpcUint8Array, consts.DPC_STATUS_REG, consts.DPC_STATUS_FLUSH);
      }
      if (value & consts.DPC_SET_FLUSH) {
        this.setFlag(core.memory.dpcUint8Array, consts.DPC_STATUS_REG, consts.DPC_STATUS_FLUSH);
      }
    };
    this.writeDPC = function(offset, value, pc, isFromDelaySlot) {
      switch (offset) {
        case consts.DPC_STATUS_REG:
          this.writeDPCStatusReg(value, pc, isFromDelaySlot);
          break;
        case consts.DPC_START_REG:
          core.memory.setInt32(core.memory.dpcUint8Array, offset, value);
          break;
        case consts.DPC_END_REG:
          core.memory.setInt32(core.memory.dpcUint8Array, offset, value);
          this.processRDPList();
          break;
        case consts.DPC_CLOCK_REG:
        case consts.DPC_BUFBUSY_REG:
        case consts.DPC_PIPEBUSY_REG:
        case consts.DPC_TMEM_REG:
          break;
        default:
          core.memory.setInt32(core.memory.dpcUint8Array, offset, value);
      }
    };
    this.writePIStatusReg = function(value, pc, isFromDelaySlot) {
      if (value & consts.PI_STATUS_CLR_INTR) {
        this.clearMIInterrupt(consts.MI_INTR_PI);
      }
      if (value & consts.PI_STATUS_RESET) {
        if (core.memory.getUint32(core.memory.piUint8Array, consts.PI_STATUS_REG) & (consts.PI_STATUS_IO_BUSY | consts.PI_STATUS_DMA_BUSY)) {
          core.memory.setInt32(core.memory.piUint8Array, consts.PI_STATUS_REG, 0);
          this.triggerPIInterrupt(pc, isFromDelaySlot);
        } else {
          core.memory.setInt32(core.memory.piUint8Array, consts.PI_STATUS_REG, 0);
        }
      }
    };
    this.runSPTask = function(spDmemTask) {
      switch (spDmemTask) {
        case consts.BAD_TASK:
          break;
        case consts.GFX_TASK:
          if (core.videoHLE === null || core.videoHLE === undefined) {
            core.videoHLE = new C1964jsVideoHLE(core, core.webGL.gl);
          }
          core.settings.wireframe = document.getElementById("wireframe").checked;
          if (core.terminate === false) {
            core.videoHLE.processDisplayList();
          }
          break;
        case consts.SND_TASK:
          this.processAudioList();
          break;
        case consts.JPG_TASK:
          this.processJpegTask();
          break;
        default:
          break;
      }
      this.checkInterrupts();
      this.triggerRspBreak();
    };
    this.processAudioList = function() {
      this.clrFlag(core.memory.aiUint8Array, consts.AI_STATUS_REG, consts.AI_STATUS_FIFO_FULL);
    };
    this.processJpegTask = function() {};
    this.processRDPList = function() {};
    this.checkInterrupts = function() {
      if ((core.memory.getUint32(core.memory.miUint8Array, consts.MI_INTR_REG) & consts.MI_INTR_DP) !== 0) {
        this.triggerDPInterrupt(0, false);
      }
      if ((core.memory.getUint32(core.memory.miUint8Array, consts.MI_INTR_REG) & consts.MI_INTR_AI) !== 0) {
        this.triggerAIInterrupt(0, false);
      }
      if ((core.memory.getUint32(core.memory.miUint8Array, consts.MI_INTR_REG) & consts.MI_INTR_SI) !== 0) {
        this.triggerSIInterrupt(0, false);
      }
      if ((cp0[consts.CAUSE] & cp0[consts.STATUS] & 0x0000FF00) !== 0) {
        this.setException(consts.EXC_INT, 0, core.p, false);
      }
    };
    return this;
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.C1964jsInterrupts = C1964jsInterrupts;

}).call(this);

// Generated by CoffeeScript 1.4.0

/*1964js - JavaScript/HTML5 port of 1964 - N64 emulator
Copyright (C) 2012 Joel Middendorf

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/


(function() {
  var C1964jsVideoHLE, root;

  C1964jsVideoHLE = function(core, glx) {
    "use strict";

    var i;
    this.processDisplayList = this.callBind(this.processDisplayList, this);
    i = void 0;
    this.core = core;
    this.gl = glx;
    this.DirectX_OGL_BlendFuncMaps = [this.gl.SRC_ALPHA, this.gl.ZERO, this.gl.ONE, this.gl.SRC_COLOR, this.gl.ONE_MINUS_SRC_COLOR, this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.DST_ALPHA, this.gl.ONE_MINUS_DST_ALPHA, this.gl.DST_COLOR, this.gl.ONE_MINUS_DST_COLOR, this.gl.SRC_ALPHA_SATURATE, this.gl.SRC_ALPHA_SATURATE, this.gl.SRC_ALPHA_SATURATE];
    this.RICE_MATRIX_STACK = 60;
    this.MAX_TEXTURES = 8;
    this.MAX_VERTICES = 80;
    this.MAX_TILES = 8;
    this.tmem = new Uint8Array(1024 * 4);
    this.activeTile = 0;
    this.textureTile = [];
    this.N64VertexList = [];
    this.vtxTransformed = [];
    this.vtxNonTransformed = [];
    this.vecProjected = [];
    this.vtxProjected5 = [];
    this.geometryMode = 0;
    this.gRSP = {};
    this.matToLoad = mat4.create();
    this.gRSPworldProject = mat4.create();
    this.triangleVertexPositionBuffer = undefined;
    this.triangleVertexColorBuffer = undefined;
    this.dlistStackPointer = 0;
    this.dlistStack = [];
    this.renderer = new C1964jsRenderer(this.core.settings, this.core.webGL.gl, this.core.webGL);
    this.texImg = {};
    this.segments = [];
    this.primColor = [];
    this.fillColor = [];
    this.blendColor = [];
    this.envColor = [];
    this.triVertices = new Float32Array(16384);
    this.triColorVertices = new Uint8Array(16384);
    this.triTextureCoords = new Float32Array(16384);
    this.otherModeL = 0;
    this.otherModeH = 0;
    this.currentMicrocodeMap = this.microcodeMap0;
    i = 0;
    while (i < this.MAX_TILES) {
      this.textureTile[i] = [];
      i += 1;
    }
    i = 0;
    while (i < this.MAX_VERTICES) {
      this.N64VertexList[i] = {};
      i += 1;
    }
    i = 0;
    while (i < consts.MAX_DL_STACK_SIZE) {
      this.dlistStack[i] = {};
      i += 1;
    }
    i = 0;
    while (i < this.segments.length) {
      this.segments[i] = 0;
      i += 1;
    }
    this.gRSP.projectionMtxs = [];
    this.gRSP.modelviewMtxs = [];
    i = 0;
    while (i < this.RICE_MATRIX_STACK) {
      this.gRSP.projectionMtxs[i] = mat4.create();
      this.gRSP.modelviewMtxs[i] = mat4.create();
      i += 1;
    }
    this.gRSP.vertexMult = 10;
    this.triangleVertexTextureCoordBuffer = undefined;
    return this;
  };

  (function() {
    "use strict";
    C1964jsVideoHLE.prototype.callBind = function(fn, me) {
      return function() {
        return fn.call(me);
      };
    };
    C1964jsVideoHLE.prototype.processDisplayList = function() {
      if (this.core.showFB === true) {
        this.initBuffers();
        this.core.webGL.show3D();
        this.core.showFB = false;
        this.resetState();
      }
      this.core.webGL.beginDList();
      this.dlParserProcess();
      return this.core.interrupts.triggerSPInterrupt(0, false);
    };
    C1964jsVideoHLE.prototype.videoLog = function(msg) {};
    C1964jsVideoHLE.prototype.dlParserProcess = function() {
      var cmd, func, pc;
      this.dlistStackPointer = 0;
      this.dlistStack[this.dlistStackPointer].pc = (this.core.memory.spMemUint8Array[consts.TASK_DATA_PTR] << 24 | this.core.memory.spMemUint8Array[consts.TASK_DATA_PTR + 1] << 16 | this.core.memory.spMemUint8Array[consts.TASK_DATA_PTR + 2] << 8 | this.core.memory.spMemUint8Array[consts.TASK_DATA_PTR + 3]) >>> 0;
      this.dlistStack[this.dlistStackPointer].countdown = consts.MAX_DL_COUNT;
      this.renderReset();
      while (this.dlistStackPointer >= 0) {
        pc = this.dlistStack[this.dlistStackPointer].pc;
        cmd = this.getCommand(pc);
        func = this.currentMicrocodeMap[cmd];
        this.dlistStack[this.dlistStackPointer].pc += 8;
        this[func](pc);
        if (this.dlistStackPointer >= 0) {
          this.dlistStack[this.dlistStackPointer].countdown -= 1;
          if (this.dlistStack[this.dlistStackPointer].countdown < 0) {
            this.dlistStackPointer -= 1;
          }
        }
      }
      this.core.interrupts.triggerSPInterrupt(0, false);
    };
    C1964jsVideoHLE.prototype.RDP_GFX_PopDL = function() {
      this.dlistStackPointer -= 1;
    };
    C1964jsVideoHLE.prototype.RSP_RDP_Nothing = function(pc) {
      this.dlistStackPointer -= 1;
    };
    C1964jsVideoHLE.prototype.RSP_GBI1_MoveMem = function(pc) {
      var addr, length, type;
      addr = void 0;
      length = void 0;
      type = this.getGbi1Type(pc);
      length = this.getGbi1Length(pc);
      addr = this.getGbi1RspSegmentAddr(pc);
    };
    C1964jsVideoHLE.prototype.RSP_GBI1_SpNoop = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI1_Reserved = function(pc) {};
    C1964jsVideoHLE.prototype.setProjection = function(mat, bPush, bReplace) {
      if (bPush) {
        if (this.gRSP.projectionMtxTop >= (this.RICE_MATRIX_STACK - 1)) {
          this.gRSP.bMatrixIsUpdated = false;
          return;
        }
        this.gRSP.projectionMtxTop += 1;
        if (bReplace) {
          mat4.set(mat, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
        } else {
          mat4.multiply(this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop - 1], mat, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
        }
      } else {
        if (bReplace) {
          mat4.set(mat, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
        } else {
          mat4.multiply(this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop], mat, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
        }
      }
      this.gRSP.bMatrixIsUpdated = true;
    };
    C1964jsVideoHLE.prototype.setWorldView = function(mat, bPush, bReplace) {
      if (bPush === true) {
        if (this.gRSP.modelViewMtxTop >= (this.RICE_MATRIX_STACK - 1)) {
          this.gRSP.bMatrixIsUpdated = false;
          return;
        }
        this.gRSP.modelViewMtxTop += 1;
        if (bReplace) {
          mat4.set(mat, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
        } else {
          mat4.multiply(this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop - 1], mat, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
        }
      } else {
        if (bReplace) {
          mat4.set(mat, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
        } else {
          mat4.multiply(this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop], mat, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
        }
      }
      this.gRSP.bMatrixIsUpdated = true;
    };
    C1964jsVideoHLE.prototype.RSP_GBI0_Mtx = function(pc) {
      var addr, seg;
      addr = void 0;
      seg = this.getGbi0DlistAddr(pc);
      addr = this.getRspSegmentAddr(seg);
      this.loadMatrix(addr);
      if (this.gbi0isProjectionMatrix(pc)) {
        this.setProjection(this.matToLoad, this.gbi0PushMatrix(pc), this.gbi0LoadMatrix(pc));
      } else {
        this.setWorldView(this.matToLoad, this.gbi0PushMatrix(pc), this.gbi0LoadMatrix(pc));
      }
    };
    C1964jsVideoHLE.prototype.loadMatrix = function(addr) {
      var a, hi, i, j, k, lo;
      i = void 0;
      j = void 0;
      lo = void 0;
      hi = void 0;
      a = void 0;
      k = 0;
      i = 0;
      while (i < 4) {
        j = 0;
        while (j < 4) {
          a = addr + (i << 3) + (j << 1);
          hi = (this.core.memory.rdramUint8Array[a] << 8 | this.core.memory.rdramUint8Array[a + 1]) & 0x0000FFFF;
          lo = (this.core.memory.rdramUint8Array[a + 32] << 8 | this.core.memory.rdramUint8Array[a + 32 + 1]) & 0x0000FFFF;
          this.matToLoad[k] = ((hi << 16) | lo) / 65536.0;
          k += 1;
          j += 1;
        }
        i += 1;
      }
    };
    C1964jsVideoHLE.prototype.DLParser_SetTImg = function(pc) {
      this.texImg.format = this.getTImgFormat(pc);
      this.texImg.size = this.getTImgSize(pc);
      this.texImg.width = this.getTImgWidth(pc) + 1;
      this.texImg.addr = this.getTImgAddr(pc);
      this.texImg.bpl = this.texImg.width << this.texImg.size >> 1;
      this.texImg.changed = true;
    };
    C1964jsVideoHLE.prototype.RSP_GBI0_Vtx = function(pc) {
      var addr, num, seg, v0;
      v0 = void 0;
      seg = void 0;
      addr = void 0;
      num = this.getGbi0NumVertices(pc) + 1;
      v0 = this.getGbi0Vertex0(pc);
      seg = this.getGbi0DlistAddr(pc);
      addr = this.getRspSegmentAddr(seg);
      if ((v0 + num) > 80) {
        num = 32 - v0;
      }
      this.processVertexData(addr, v0, num);
    };
    C1964jsVideoHLE.prototype.updateCombinedMatrix = function() {
      var pmtx, vmtx;
      return;
      if (this.gRSP.bMatrixIsUpdated) {
        pmtx = void 0;
        vmtx = this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop];
        pmtx = this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop];
        mat4.multiply(pmtx, vmtx, this.gRSPworldProject);
        this.gRSP.bMatrixIsUpdated = false;
      }
    };
    C1964jsVideoHLE.prototype.processVertexData = function(addr, v0, num) {
      var a, i, texHeight, texWidth;
      a = void 0;
      i = v0;
      this.updateCombinedMatrix();
      i = v0;
      texWidth = this.textureTile[this.activeTile].width;
      texHeight = this.textureTile[this.activeTile].height;
      while (i < v0 + num) {
        a = addr + 16 * (i - v0);
        this.N64VertexList[i].x = this.getVertexX(a);
        this.N64VertexList[i].y = this.getVertexY(a);
        this.N64VertexList[i].z = this.getVertexZ(a);
        this.N64VertexList[i].s = this.getVertexS(a) / 32 / texWidth;
        this.N64VertexList[i].t = this.getVertexT(a) / 32 / texHeight;
        this.N64VertexList[i].r = this.getVertexColorR(a);
        this.N64VertexList[i].g = this.getVertexColorG(a);
        this.N64VertexList[i].b = this.getVertexColorB(a);
        this.N64VertexList[i].a = this.getVertexAlpha(a);
        i += 1;
      }
    };
    C1964jsVideoHLE.prototype.DLParser_SetCImg = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI0_DL = function(pc) {
      var addr, param, seg;
      param = void 0;
      seg = this.getGbi0DlistAddr(pc);
      addr = this.getRspSegmentAddr(seg);
      param = this.getGbi0DlistParam(pc);
      if (param === consts.RSP_DLIST_PUSH) {
        this.dlistStackPointer += 1;
      }
      this.dlistStack[this.dlistStackPointer].pc = addr;
      this.dlistStack[this.dlistStackPointer].countdown = consts.MAX_DL_COUNT;
    };
    C1964jsVideoHLE.prototype.DLParser_SetCombine = function(pc) {
      var w0, w1;
      this.combineA0 = this.getCombineA0(pc);
      this.combineB0 = this.getCombineB0(pc);
      this.combineC0 = this.getCombineC0(pc);
      this.combineD0 = this.getCombineD0(pc);
      this.combineA0a = this.getCombineA0a(pc);
      this.combineB0a = this.getCombineB0a(pc);
      this.combineC0a = this.getCombineC0a(pc);
      this.combineD0a = this.getCombineD0a(pc);
      this.combineA1 = this.getCombineA1(pc);
      this.combineB1 = this.getCombineB1(pc);
      this.combineC1 = this.getCombineC1(pc);
      this.combineD1 = this.getCombineD1(pc);
      this.combineA1a = this.getCombineA1a(pc);
      this.combineB1a = this.getCombineB1a(pc);
      this.combineC1a = this.getCombineC1a(pc);
      this.combineD1a = this.getCombineD1a(pc);
      w0 = this.core.memory.rdramUint8Array[pc] << 24 | this.core.memory.rdramUint8Array[pc + 1] << 16 | this.core.memory.rdramUint8Array[pc + 2] << 8 | this.core.memory.rdramUint8Array[pc + 3];
      w1 = this.core.memory.rdramUint8Array[pc + 4] << 24 | this.core.memory.rdramUint8Array[pc + 5] << 16 | this.core.memory.rdramUint8Array[pc + 6] << 8 | this.core.memory.rdramUint8Array[pc + 7];
    };
    C1964jsVideoHLE.prototype.RSP_GBI1_MoveWord = function(pc) {
      var dwBase, dwSegment;
      switch (this.getGbi0MoveWordType(pc)) {
        case consts.RSP_MOVE_WORD_MATRIX:
          this.RSP_RDP_InsertMatrix();
          break;
        case consts.RSP_MOVE_WORD_SEGMENT:
          dwBase = void 0;
          dwSegment = (this.getGbi0MoveWordOffset(pc) >> 2) & 0x0F;
          dwBase = this.getGbi0MoveWordValue(pc) & 0x00FFFFFF;
          this.segments[dwSegment] = dwBase;
          break;
      }
    };
    C1964jsVideoHLE.prototype.renderReset = function() {
      this.resetMatrices();
      this.gRSP.numVertices = 0;
      this.gRSP.curTile = 0;
      this.gRSP.fTexScaleX = 1 / 32.0;
      this.gRSP.fTexScaleY = 1 / 32.0;
    };
    C1964jsVideoHLE.prototype.resetMatrices = function() {
      this.gRSP.projectionMtxTop = 0;
      this.gRSP.modelViewMtxTop = 0;
      this.gRSP.projectionMtxs[0] = mat4.create();
      this.gRSP.modelviewMtxs[0] = mat4.create();
      mat4.identity(this.gRSP.modelviewMtxs[0]);
      mat4.identity(this.gRSP.projectionMtxs[0]);
      this.gRSP.bMatrixIsUpdated = true;
      this.updateCombinedMatrix();
    };
    C1964jsVideoHLE.prototype.RSP_RDP_InsertMatrix = function() {
      this.updateCombinedMatrix();
      this.gRSP.bMatrixIsUpdated = false;
    };
    C1964jsVideoHLE.prototype.DLParser_SetScissor = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI1_SetOtherModeH = function(pc) {
      this.otherModeH = this.getOtherModeH();
    };
    C1964jsVideoHLE.prototype.RSP_GBI1_SetOtherModeL = function(pc) {
      this.otherModeL = this.getOtherModeL();
    };
    C1964jsVideoHLE.prototype.RSP_GBI0_Sprite2DBase = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI0_Tri4 = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI1_RDPHalf_Cont = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI1_RDPHalf_2 = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI1_RDPHalf_1 = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI1_Line3D = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI1_ClearGeometryMode = function(pc) {
      var data;
      data = this.getClearGeometryMode(pc);
      this.geometryMode &= ~data;
    };
    C1964jsVideoHLE.prototype.RSP_GBI1_SetGeometryMode = function(pc) {
      var data;
      data = this.getSetGeometryMode(pc);
      this.geometryMode |= data;
    };
    C1964jsVideoHLE.prototype.RSP_GBI1_EndDL = function(pc) {
      this.RDP_GFX_PopDL();
      this.drawScene(false, 7);
    };
    C1964jsVideoHLE.prototype.RSP_GBI1_Texture = function(pc) {
      var tile;
      tile = this.getTextureTile(pc);
      this.textureTile[tile].on = this.getTextureOn(pc);
      this.textureTile[tile].level = this.getTextureLevel(pc);
      this.textureTile[tile].scales = this.getTextureScaleS(pc) / 0x8000;
      this.textureTile[tile].scalet = this.getTextureScaleT(pc) / 0x8000;
    };
    C1964jsVideoHLE.prototype.RSP_GBI1_PopMtx = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI1_CullDL = function(pc) {};
    C1964jsVideoHLE.prototype.RSP_GBI1_Tri1 = function(pc) {
      var cmd, didSucceed, flag, func, v0, v1, v2;
      v0 = this.getGbi0Tri1V0(pc) / this.gRSP.vertexMult;
      v1 = this.getGbi0Tri1V1(pc) / this.gRSP.vertexMult;
      v2 = this.getGbi0Tri1V2(pc) / this.gRSP.vertexMult;
      flag = this.getGbi0Tri1Flag(pc);
      didSucceed = this.prepareTriangle(v0, v1, v2);
      if (didSucceed === false) {
        return;
      }
      cmd = this.getCommand(pc + 8);
      func = this.currentMicrocodeMap[cmd];
    };
    C1964jsVideoHLE.prototype.RSP_GBI1_Noop = function(pc) {};
    C1964jsVideoHLE.prototype.RDP_TriFill = function(pc) {};
    C1964jsVideoHLE.prototype.RDP_TriFillZ = function(pc) {};
    C1964jsVideoHLE.prototype.RDP_TriTxtr = function(pc) {};
    C1964jsVideoHLE.prototype.RDP_TriTxtrZ = function(pc) {};
    C1964jsVideoHLE.prototype.RDP_TriShade = function(pc) {};
    C1964jsVideoHLE.prototype.RDP_TriShadeZ = function(pc) {};
    C1964jsVideoHLE.prototype.RDP_TriShadeTxtr = function(pc) {};
    C1964jsVideoHLE.prototype.RDP_TriShadeTxtrZ = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_TexRect = function(pc) {
      var dsdx, dtdy, s, t, tileno, xh, xl, yh, yl;
      xh = this.getTexRectXh(pc) / 4;
      yh = this.getTexRectYh(pc) / 4;
      tileno = this.getTexRectTileNo(pc);
      xl = this.getTexRectXl(pc) / 4;
      yl = this.getTexRectYl(pc) / 4;
      s = this.getTexRectS(pc) / 32;
      t = this.getTexRectT(pc) / 32;
      dsdx = this.getTexRectDsDx(pc) / 1024;
      dtdy = this.getTexRectDtDy(pc) / 1024;
      this.renderer.texRect(xl, yl, xh, yh, s, t, dsdx, dtdy, this.textureTile[tileno], this.tmem, this);
      this.dlistStack[this.dlistStackPointer].pc += 8;
      this.hasTexture = true;
    };
    C1964jsVideoHLE.prototype.DLParser_TexRectFlip = function(pc) {
      this.dlistStack[this.dlistStackPointer].pc += 8;
    };
    C1964jsVideoHLE.prototype.DLParser_RDPLoadSynch = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_RDPPipeSynch = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_RDPTileSynch = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_RDPFullSynch = function(pc) {
      this.core.interrupts.triggerDPInterrupt(0, false);
    };
    C1964jsVideoHLE.prototype.DLParser_SetKeyGB = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_SetKeyR = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_SetConvert = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_SetPrimDepth = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_RDPSetOtherMode = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_LoadTLut = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_SetTileSize = function(pc) {
      var tile;
      tile = this.getSetTileSizeTile(pc);
      this.textureTile[tile].uls = this.getSetTileSizeUls(pc);
      this.textureTile[tile].ult = this.getSetTileSizeUlt(pc);
      this.textureTile[tile].lrs = (this.getSetTileSizeLrs(pc) >> 2) + 1;
      this.textureTile[tile].lrt = (this.getSetTileSizeLrt(pc) >> 2) + 1;
      this.textureTile[tile].width = this.textureTile[tile].lrs - this.textureTile[tile].uls;
      this.textureTile[tile].height = this.textureTile[tile].lrt - this.textureTile[tile].ult;
    };
    C1964jsVideoHLE.prototype.DLParser_LoadBlock = function(pc) {
      var bytesToXfer, dxt, i, lrs, tile, uls, ult;
      tile = this.getLoadBlockTile(pc);
      uls = this.getLoadBlockUls(pc);
      ult = this.getLoadBlockUlt(pc);
      lrs = this.getLoadBlockLrs(pc) + 1;
      dxt = this.getLoadBlockDxt(pc);
      bytesToXfer = lrs * this.textureTile[tile].siz;
      if (bytesToXfer > 4096) {
        console.error("LoadBlock is making too large of a transfer. " + bytesToXfer + " bytes");
      }
      i = 0;
      while (i < bytesToXfer) {
        this.tmem[i] = this.core.memory.rdramUint8Array[this.texImg.addr + i];
        i++;
      }
    };
    C1964jsVideoHLE.prototype.DLParser_LoadTile = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_SetTile = function(pc) {
      var tile;
      tile = this.getSetTileTile(pc);
      this.activeTile = tile;
      this.textureTile[tile].fmt = this.getSetTileFmt(pc);
      this.textureTile[tile].siz = this.getSetTileSiz(pc);
      this.textureTile[tile].line = this.getSetTileLine(pc);
      this.textureTile[tile].tmem = this.getSetTileTmem(pc);
      this.textureTile[tile].pal = this.getSetTilePal(pc);
      this.textureTile[tile].cmt = this.getSetTileCmt(pc);
      this.textureTile[tile].cms = this.getSetTileCms(pc);
      this.textureTile[tile].maskt = this.getSetTileMaskt(pc);
      this.textureTile[tile].masks = this.getSetTileMasks(pc);
      this.textureTile[tile].shiftt = this.getSetTileShiftt(pc);
      this.textureTile[tile].shifts = this.getSetTileShifts(pc);
    };
    C1964jsVideoHLE.prototype.DLParser_FillRect = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_SetFillColor = function(pc) {
      this.fillColor = [];
      this.fillColor.push(this.getSetFillColorR(pc) / 255.0);
      this.fillColor.push(this.getSetFillColorG(pc) / 255.0);
      this.fillColor.push(this.getSetFillColorB(pc) / 255.0);
      this.fillColor.push(this.getSetFillColorA(pc) / 255.0);
    };
    C1964jsVideoHLE.prototype.DLParser_SetFogColor = function(pc) {};
    C1964jsVideoHLE.prototype.DLParser_SetBlendColor = function(pc) {
      this.blendColor = [];
      this.blendColor.push(this.getSetFillColorR(pc) / 255.0);
      this.blendColor.push(this.getSetFillColorG(pc) / 255.0);
      this.blendColor.push(this.getSetFillColorB(pc) / 255.0);
      this.blendColor.push(this.getSetFillColorA(pc) / 255.0);
    };
    C1964jsVideoHLE.prototype.blendFunc = function(src, dest) {
      this.gl.blendFunc(DirectX_OGL_BlendFuncMaps[src], DirectX_OGL_BlendFuncMaps[dest]);
    };
    C1964jsVideoHLE.prototype.DLParser_SetPrimColor = function(pc) {
      this.primColor = [];
      this.primColor.push((this.getSetPrimColorR(pc)) / 255);
      this.primColor.push((this.getSetPrimColorG(pc)) / 255);
      this.primColor.push((this.getSetPrimColorB(pc)) / 255);
      this.primColor.push(this.getSetPrimColorA(pc) / 255);
    };
    C1964jsVideoHLE.prototype.DLParser_SetEnvColor = function(pc) {
      this.envColor = [];
      this.envColor.push((this.getSetEnvColorR(pc)) / 255.0);
      this.envColor.push((this.getSetEnvColorG(pc)) / 255.0);
      this.envColor.push((this.getSetEnvColorB(pc)) / 255.0);
      this.envColor.push(this.getSetEnvColorA(pc) / 255.0);
    };
    C1964jsVideoHLE.prototype.DLParser_SetZImg = function(pc) {};
    C1964jsVideoHLE.prototype.prepareTriangle = function(dwV0, dwV1, dwV2) {
      var didSucceed, textureFlag;
      didSucceed = void 0;
      textureFlag = false;
      didSucceed = this.initVertex(dwV0, this.gRSP.numVertices, textureFlag);
      if (didSucceed) {
        didSucceed = this.initVertex(dwV1, this.gRSP.numVertices + 1, textureFlag);
      }
      if (didSucceed) {
        didSucceed = this.initVertex(dwV2, this.gRSP.numVertices + 2, textureFlag);
      }
      if (didSucceed) {
        this.gRSP.numVertices += 3;
      }
      return didSucceed;
    };
    C1964jsVideoHLE.prototype.initVertex = function(dwV, vtxIndex, bTexture) {
      var colorOffset, offset, texOffset;
      if (dwV >= consts.MAX_VERTS) {
        return false;
      }
      offset = 3 * this.triangleVertexPositionBuffer.numItems;
      this.triVertices[offset] = this.N64VertexList[dwV].x;
      this.triVertices[offset + 1] = this.N64VertexList[dwV].y;
      this.triVertices[offset + 2] = this.N64VertexList[dwV].z - 2.0;
      this.triangleVertexPositionBuffer.numItems += 1;
      colorOffset = this.triangleVertexColorBuffer.numItems << 2;
      this.triColorVertices[colorOffset] = this.N64VertexList[dwV].r | 128;
      this.triColorVertices[colorOffset + 1] = this.N64VertexList[dwV].g | 128;
      this.triColorVertices[colorOffset + 2] = this.N64VertexList[dwV].b | 128;
      this.triColorVertices[colorOffset + 3] = this.N64VertexList[dwV].a;
      this.triangleVertexColorBuffer.numItems += 1;
      texOffset = this.triangleVertexTextureCoordBuffer.numItems << 1;
      this.triTextureCoords[texOffset] = this.N64VertexList[dwV].s;
      this.triTextureCoords[texOffset + 1] = this.N64VertexList[dwV].t;
      this.triangleVertexTextureCoordBuffer.numItems += 1;
      return true;
    };
    C1964jsVideoHLE.prototype.drawScene = function(useTexture, tileno) {
      var canvasheight, canvaswidth, colorsTexture, texture, tile;
      this.gl.useProgram(this.core.webGL.shaderProgram);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.enable(this.gl.BLEND);
      if (this.triangleVertexPositionBuffer.numItems > 0) {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.triVertices.subarray(0, this.triangleVertexPositionBuffer.numItems * this.triangleVertexPositionBuffer.itemSize * 4), this.gl.STATIC_DRAW);
        this.gl.enableVertexAttribArray(this.core.webGL.shaderProgram.vertexPositionAttribute);
        this.gl.vertexAttribPointer(this.core.webGL.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      }
      if (this.triangleVertexColorBuffer.numItems > 0) {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexColorBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.triColorVertices.subarray(0, this.triangleVertexColorBuffer.numItems * this.triangleVertexColorBuffer.itemSize), this.gl.STATIC_DRAW);
        this.gl.enableVertexAttribArray(this.core.webGL.shaderProgram.vertexColorAttribute);
        this.gl.vertexAttribPointer(this.core.webGL.shaderProgram.vertexColorAttribute, this.triangleVertexColorBuffer.itemSize, this.gl.UNSIGNED_BYTE, true, 0, 0);
      }
      if (this.triangleVertexTextureCoordBuffer.numItems > 0) {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexTextureCoordBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.triTextureCoords.subarray(0, this.triangleVertexTextureCoordBuffer.numItems * this.triangleVertexTextureCoordBuffer.itemSize * 4), this.gl.STATIC_DRAW);
        this.gl.enableVertexAttribArray(this.core.webGL.shaderProgram.textureCoordAttribute);
        this.gl.vertexAttribPointer(this.core.webGL.shaderProgram.textureCoordAttribute, this.triangleVertexTextureCoordBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
        tile = this.textureTile[this.activeTile];
        canvaswidth = this.pow2roundup(tile.width);
        canvasheight = this.pow2roundup(tile.height);
        texture = this.renderer.formatTexture(tile, this.tmem, canvaswidth, canvasheight);
        colorsTexture = this.gl.createTexture();
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, colorsTexture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, tile.width, tile.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, texture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
        this.gl.uniform1i(this.core.webGL.shaderProgram.samplerUniform, colorsTexture);
      }
      if (this.primColor.length > 0) {
        this.gl.uniform4fv(this.core.webGL.shaderProgram.uPrimColor, this.primColor);
      }
      if (this.fillColor.length > 0) {
        this.gl.uniform4fv(this.core.webGL.shaderProgram.uFillColor, this.fillColor);
      }
      if (this.envColor.length > 0) {
        this.gl.uniform4fv(this.core.webGL.shaderProgram.uEnvColor, this.envColor);
      }
      if (this.blendColor.length > 0) {
        this.gl.uniform4iv(this.core.webGL.shaderProgram.uBlendColor, this.blendColor);
      }
      this.gl.uniform1i(this.core.webGL.shaderProgram.otherModeL, this.otherModeL);
      this.gl.uniform1i(this.core.webGL.shaderProgram.otherModeH, this.otherModeH);
      this.core.webGL.setCombineUniforms(this.core.webGL.shaderProgram);
      this.gl.uniform1i(this.core.webGL.shaderProgram.wireframeUniform, this.core.settings.wireframe ? 1 : 0);
      this.gl.uniformMatrix4fv(this.core.webGL.shaderProgram.pMatrixUniform, false, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
      this.gl.uniformMatrix4fv(this.core.webGL.shaderProgram.mvMatrixUniform, false, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
      if (this.triangleVertexPositionBuffer.numItems > 0) {
        if (this.core.settings.wireframe === true) {
          this.gl.drawArrays(this.gl.LINES, 0, this.triangleVertexPositionBuffer.numItems);
        } else {
          this.gl.drawArrays(this.gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);
        }
      }
      this.resetState();
    };
    C1964jsVideoHLE.prototype.resetState = function() {
      this.triangleVertexPositionBuffer.numItems = 0;
      this.triangleVertexColorBuffer.numItems = 0;
      this.triangleVertexTextureCoordBuffer.numItems = 0;
    };
    return C1964jsVideoHLE.prototype.initBuffers = function() {
      this.triangleVertexPositionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
      this.triangleVertexPositionBuffer.itemSize = 3;
      this.triangleVertexPositionBuffer.numItems = 0;
      this.triangleVertexColorBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexColorBuffer);
      this.triangleVertexColorBuffer.itemSize = 4;
      this.triangleVertexColorBuffer.numItems = 0;
      this.triangleVertexTextureCoordBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexTextureCoordBuffer);
      this.triangleVertexTextureCoordBuffer.itemSize = 2;
      this.triangleVertexTextureCoordBuffer.numItems = 0;
    };
  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.C1964jsVideoHLE = C1964jsVideoHLE;

}).call(this);
